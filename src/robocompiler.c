/*
 * robocompiler.c
 *
 * By Steven Smith
 */

#include "robocode.h"
#include <stdlib.h>
#include <stdio.h>

/*
 * Tokens generated by the lexer.
 */
enum token {
    token_ident, /* Generic identifier, gets replaced in the second pass of lexer */
    token_num,
    token_comma,
    token_colon,
    token_label,
    /* Instructions */
    token_abs,
    token_add,
    token_and,
    token_arccos,
    token_arcsin,
    token_arctan,
    token_beep,
    token_call,
    token_chs,
    token_cos,
    token_debug,
    token_dist,
    token_div,
    token_drop,
    token_dropall,
    token_dup,
    token_end,
    token_eq,
    token_gt,
    token_icon,
    token_if,
    token_ife,
    token_ifeg,
    token_ifg,
    token_jump,
    token_lt,
    token_max,
    token_min,
    token_mod,
    token_mov,
    token_mul,
    token_ne,
    token_nop,
    token_not,
    token_or,
    token_peek,
    token_pop,
    token_print,
    token_push,
    token_pushr,
    token_random,
    token_recall,
    token_return,
    token_roll,
    token_setparam,
    token_sin,
    token_sound,
    token_sqrt,
    token_store,
    token_sub,
    token_swap,
    token_sync,
    token_tan,
    token_test,
    token_vrecall,
    token_vstore,
    token_xor,
    token_reg /* Registers */
};

typedef struct token_list {
    enum token t;
    char *ident;
    int value;
    int line_number;
    struct token_list *next;
} token_list;

static token_list *tl = NULL;
static token_list *tl_end = NULL;

#define IDENTBUF_SIZE 50
static char ident_buf[IDENTBUF_SIZE + 1];

#define isalpha(c) \
    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
#define isalphanum(c) \
    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
#define isnum(c) \
    (c >= '0' && c <= '9')

static void build_token_ident( int pos, int current_line ) {
    char *s;
    int i;
    token_list *new_token = (token_list*)malloc(sizeof(token_list));
    s = (char*)malloc(sizeof(char) * pos + 1); /* I know this is 1 * pos + 1 */
    new_token->t = token_ident;
    for( i = 0; i < pos; i++ ) {
        s[i] = ident_buf[i];
    }
    s[pos] = '\0';
    new_token->ident = s;
    new_token->line_number = current_line;
    new_token->next = NULL;
    if( !tl ) {
        tl = new_token;
        tl_end = new_token;
    }
    else {
        tl_end->next = new_token;
        tl_end = new_token;
    }
}

static void build_token_num( int pos, int current_line ) {
    token_list *new_token = (token_list*)malloc(sizeof(token_list));
    new_token->t = token_num;
    new_token->ident = NULL;
    ident_buf[pos] = '\0';
    new_token->value = atoi(ident_buf);
    new_token->line_number = current_line;
    new_token->next = NULL;
    if( !tl ) {
        tl = new_token;
        tl_end = new_token;
    }
    else {
        tl_end->next = new_token;
        tl_end = new_token;
    }
}

static void build_token_comma( int current_line ) {
    token_list *new_token = (token_list*)malloc(sizeof(token_list));
    new_token->t = token_comma;
    new_token->ident = NULL;
    new_token->line_number = current_line;
    new_token->next = NULL;
    if( !tl ) {
        tl = new_token;
        tl_end = new_token;
    }
    else {
        tl_end->next = new_token;
        tl_end = new_token;
    }
}

static void build_token_colon( int current_line ) {
    token_list *new_token = (token_list*)malloc(sizeof(token_list));
    new_token->t = token_colon;
    new_token->ident = NULL;
    new_token->line_number = current_line;
    new_token->next = NULL;
    if( !tl ) {
        tl = new_token;
        tl_end = new_token;
    }
    else {
        tl_end->next = new_token;
        tl_end = new_token;
    }
}

static int build_token_list_f( FILE *fp ) {
    int curr_char;
    int ident_pos;
    int current_line;
    if( !fp ) {
        return -1;
    }
    curr_char = fgetc(fp);
    current_line = 1;
    while( curr_char != EOF ) {
        /* Ident builder */
        if( isalpha(curr_char) ) {
            ident_pos = 0;
            do {
                ident_buf[ident_pos] = curr_char;
                ident_pos++;
                curr_char = fgetc(fp);
            } while( curr_char != EOF && isalphanum(curr_char) && ident_pos < IDENTBUF_SIZE );
            build_token_ident(ident_pos, current_line);
            continue;
        }
        /* Number builder */
        else if( isnum(curr_char) || curr_char == '-' ) {
            ident_pos = 0;
            do {
                ident_buf[ident_pos] = curr_char;
                ident_pos++;
                curr_char = fgetc(fp);
            } while( curr_char != EOF && isnum(curr_char)  && ident_pos < IDENTBUF_SIZE );
            build_token_num(ident_pos, current_line);
            continue;
        }
        /* Grab commas */
        else if( curr_char == ',' ) {
            build_token_comma(current_line);
        }
        /* Grab semicolons */
        else if( curr_char == ':' ) {
            build_token_colon(current_line);
        }
        /* Handle comments */
        else if( curr_char == '#' ) {
            /* Eat everything until EOL */
            do {
                curr_char = fgetc(fp);
            } while( curr_char != EOF && curr_char != '\n' && curr_char != '\r' );
        }
        if( curr_char == '\n' ) {
            current_line++;
        }
        curr_char = fgetc(fp);
    }
    return 0;
}

static int ident_compare( char *c1, char *c2 ) {
    int i = 0;
    if( c1 && c2 ) {
        while( c1[i] && c2[i] && c1[i] == c2[i] ) {
            i++;
        }
        if( c1[i] == c2[i] ) {
            return 1;
        }
    }
    return 0;
}

static int reg_check( token_list *tok ) {
    int value, i;
    char *c = tok->ident;
    if( c && c[0] == 'r' ) {
        i = 1;
        value = 0;
        while( c[i] && c[i] >= '0' && c[i] <= '9' ) {
            value = value * 10 + (c[i] - '0');
            i++;
        }
        if( !c[i] && value < 450 ) {
            tok->t = token_reg;
            tok->value = value;
            free(tok->ident);
            tok->ident = NULL;
            return 1;
        }
        else { /* Bad value or found something that's not a number */
            return 0;
        }
    }
    else {
        return 0;
    }
}

typedef struct token_trie {
    char val;
    union {
        enum token tok;
        enum special_reg reg;
        int none;
    } type;
    int pick;
    struct token_trie *next;
    struct token_trie *child;
} token_trie;

static token_trie *parser_trie = NULL;

static void insert_into_trie( char *name, enum token t, enum special_reg r, int which ) {
    char *c = name;
    token_trie *trie;
    token_trie *trie_parent;
    token_trie *trie_sibling = NULL;
    /* If this is the first entry, we need to make it and move to the next level */
    if( parser_trie == NULL ) {
        parser_trie = (token_trie*)malloc(sizeof(token_trie));
        parser_trie->val = *c;
        parser_trie->next = NULL;
        parser_trie->child = NULL;
        c++;
        trie_parent = parser_trie;
        trie = NULL;
    }
    /* Otherwise we start at the top level */
    else {
        trie_parent = NULL;
        trie = parser_trie;
    }
    while( *c ) {
        if( !trie ) {
            trie = (token_trie*)malloc(sizeof(token_trie));
            trie->val = *c;
            trie->next = NULL;
            trie->child = NULL;
            c++;
            /* If we have a sibling, attach new node to it */
            if( trie_sibling ) {
                trie_sibling->next = trie;
                trie_sibling = NULL;
            }
            /* Otherwise attach it to the parent */
            else if( trie_parent ) {
                trie_parent->child = trie;
            }
            /* Still have characters to go, so no endpoint */
            if( *c ) {
                trie->pick = 0;
                trie_parent = trie;
                trie = trie->child;
            }
            /* Hit the end of the entry, so set the values */
            else {
                if( which == 1 ) {
                    trie->type.tok = t;
                    trie->pick = 1;
                }
                else if( which == 2 ) {
                    trie->type.reg = r;
                    trie->pick = 2;
                }
                else {
                    trie->pick = 0;
                }
            }
        }
        /* Node already exists, so traverse */
        else {
            if( trie->val == *c ) {
                c++;
                if( *c == 0 ) {
                    if( which == 1 ) {
                        trie->type.tok = t;
                        trie->pick = 1;
                    }
                    else if( which == 2 ) {
                        trie->type.reg = r;
                        trie->pick = 2;
                    }
                    else {
                        trie->pick = 0;
                    }
                }
                trie_parent = trie;
                trie = trie->child;
                trie_sibling = NULL;
            }
            else {
                trie_sibling = trie;
                trie = trie->next;
            }
        }
    }
}

static void insert_token( char *name, enum token t ) {
    insert_into_trie(name, t, 0, 1);
}

static void insert_register( char *name, enum special_reg r ) {
    insert_into_trie(name, 0, r, 2);
}

static token_trie * trie_lookup( char *name ) {
    token_trie *t = parser_trie;
    char *n = name;
    while( *n ) {
        if( !t ) {
            return NULL;
        }
        else {
            if( t->val == *n ) {
                n++;
                if( *n ) {
                    t = t->child;
                }
                else {
                    return t;
                }
            }
            else {
                t = t->next;
            }
        }
    }
    return NULL;
}

static int convert_ident_token( token_list *tok ) {
    token_trie *t = trie_lookup(tok->ident);
    if( t ) {
        if( t->pick == 1 ) {
            tok->t = t->type.tok;
        }
        else if( t->pick == 2 ) {
            tok->t = token_reg;
            tok->value = (int)t->type.reg;
        }
        else {
            return 0;
        }
        free(tok->ident);
        tok->ident = NULL;
        return 1;
    }
    else {
        return 0;
    }
}

static void convert_ident_tokens() {
    token_list *tok = tl;
    /* Step 1: Build trie */
    /* Instructions */
    insert_token("abs", token_abs);
    insert_token("add", token_add);
    insert_token("and", token_and);
    insert_token("arccos", token_arccos);
    insert_token("arcsin", token_arcsin);
    insert_token("arctan", token_arctan);
    insert_token("beep", token_beep);
    insert_token("call", token_call);
    insert_token("chs", token_chs);
    insert_token("cos", token_cos);
    insert_token("debug", token_debug);
    insert_token("dist", token_dist);
    insert_token("div", token_div);
    insert_token("drop", token_drop);
    insert_token("dropall", token_dropall);
    insert_token("dup", token_dup);
    insert_token("end", token_end);
    insert_token("eq", token_eq);
    insert_token("gt", token_gt);
    insert_token("icon", token_icon);
    insert_token("if", token_if);
    insert_token("ife", token_ife);
    insert_token("ifeg", token_ifeg);
    insert_token("ifg", token_ifg);
    insert_token("jump", token_jump);
    insert_token("lt", token_lt);
    insert_token("max", token_max);
    insert_token("min", token_min);
    insert_token("mod", token_mod);
    insert_token("mov", token_mov);
    insert_token("mul", token_mul);
    insert_token("ne", token_ne);
    insert_token("nop", token_nop);
    insert_token("not", token_not);
    insert_token("or", token_or);
    insert_token("peek", token_peek);
    insert_token("pop", token_pop);
    insert_token("print", token_print);
    insert_token("push", token_push);
    insert_token("random", token_random);
    insert_token("recall", token_recall);
    insert_token("return", token_return);
    insert_token("roll", token_roll);
    insert_token("setparam", token_setparam);
    insert_token("sin", token_sin);
    insert_token("sound", token_sound);
    insert_token("sqrt", token_sqrt);
    insert_token("store", token_store);
    insert_token("sub", token_sub);
    insert_token("swap", token_swap);
    insert_token("sync", token_sync);
    insert_token("tan", token_tan);
    insert_token("test", token_test);
    insert_token("vrecall", token_vrecall);
    insert_token("vstore", token_vstore);
    insert_token("xor", token_xor);
    /* Registers */
    insert_register("aim", reg_aim);
    insert_register("bullet", reg_bullet);
    insert_register("channel", reg_channel);
    insert_register("chronon", reg_chronon);
    insert_register("collision", reg_collision);
    insert_register("damage", reg_damage);
    insert_register("energy", reg_energy);
    insert_register("fire", reg_fire);
    insert_register("friend", reg_friend);
    insert_register("hellbore", reg_hellbore);
    insert_register("history", reg_history);
    insert_register("id", reg_id);
    insert_register("kills", reg_kills);
    insert_register("look", reg_look);
    insert_register("mine", reg_mine);
    insert_register("missile", reg_missile);
    insert_register("movex", reg_movex);
    insert_register("movey", reg_movey);
    insert_register("nuke", reg_nuke);
    insert_register("probe", reg_probe);
    insert_register("radar", reg_radar);
    insert_register("range", reg_range);
    insert_register("robots", reg_robots);
    insert_register("scan", reg_scan);
    insert_register("shield", reg_shield);
    insert_register("signal", reg_signal);
    insert_register("speedx", reg_speedx);
    insert_register("speedy", reg_speedy);
    insert_register("stunner", reg_stunner);
    insert_register("teammates", reg_teammates);
    insert_register("wall", reg_wall);
    insert_register("x", reg_x);
    insert_register("y", reg_y);
    /* Step 2: Convert tokens */
    while( tok != NULL ) {
        if( tok->t == token_ident ) {
            if( !convert_ident_token(tok) ) {
                if( !reg_check(tok) ) {
                    /* Default to label */
                    tok->t = token_label;
                }
            }
        }
        tok = tok->next;
    }
}

enum errors {
    err_no_err = 0,
    err_reg1_expected = 1,
    err_comma_expected = 2,
    err_unexpected_eof = 3,
    err_regnum2_expected = 4,
    err_regnum3_expected = 5,
    err_labelnum_expected = 6,
    err_duplabel = 7,
    err_colon_expected = 8,
    err_labelnumreg_expected = 9,
    err_unknown_token = 10,
    err_nonexistant_label = 11
};

static int error = 0;
static int error_line = 0;

typedef struct op_list {
    RW_Robo_Op ops[5000]; /* We'll start with 5k, if we need more we'll alloc another 5k */
    int length;
    struct op_list *next;
} op_list;

typedef struct label_loc_map {
    char *name;
    int location;
    struct label_loc_map *prev;
} label_loc_map;

static op_list *ops = NULL;

static label_loc_map *lmap = NULL; /* Label->location map */
static label_loc_map *fmap = NULL; /* Ops that are waiting for a label to be resolved */

static op_list * new_op_list() {
    op_list *new_list;
    new_list = (op_list*)malloc(sizeof(op_list));
    new_list->length = 0;
    new_list->next = NULL;
    return new_list;
}

static void create_instruction( RW_Robo_Op instruction ) {
    op_list *list;
    if( !ops ) {
        ops = new_op_list();
    }
    list = ops;
    while( list->next ) {
        list = list->next; /* Get last op list to append */
    }
    if( list->length == 5000 ) { /* Create new list if current list is full */
        list->next = new_op_list();
        list = list->next;
    }
    list->ops[list->length] = instruction;
    list->length++;
}

static void update_branch_instruction( label_loc_map *map, int location ) {
    op_list *list;
    int op_loc;
    label_loc_map *other_map;
    list = ops;
    op_loc = map->location;
    while( op_loc > 5000 ) {
        op_loc -= 5000;
        list = list->next;
    }
    update_op_imme(list->ops[op_loc], location);
    /* Remove the branch from the update list */
    if( map == fmap ) {
        fmap = fmap->prev;
    }
    else {
        /* Find map entry right before this one */
        other_map = fmap;
        while( other_map->prev != map ) {
            other_map = other_map->prev;
        }
        other_map->prev = map->prev;
    }
    free(map);
}

static void create_mova( int value ) {
    RW_Robo_Op new_op;
    encode_op_imme(new_op, op_mova, value);
    create_instruction(new_op);
}

static void create_movb( int value ) {
    RW_Robo_Op new_op;
    encode_op_imme(new_op, op_movb, value);
    create_instruction(new_op);
}

static token_list * three_reg_op( token_list *t, int op ) {
    int reg1, reg2, reg3;
    RW_Robo_Op new_op;
    token_list *tok = t;
    /* Get reg1 */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_reg ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_reg1_expected;
        return NULL;
    }
    reg1 = tok->value;
    /* Eat a comma, get reg2 or first immediate */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_comma ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_comma_expected;
        return NULL;
    }
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t == token_reg ) {
        reg2 = tok->value;
    }
    else if( tok->t == token_num ) {
        reg2 = reg_a;
        create_mova(tok->value);
    }
    else {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_regnum2_expected;
        return NULL;
    }
    /* Eat a comma, get reg3 or second immediate */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_comma ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_comma_expected;
        return NULL;
    }
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t == token_reg ) {
        reg3 = tok->value;
    }
    else if( tok->t == token_num ) {
        reg3 = reg_b;
        create_movb(tok->value);
    }
    else {
        error_line = tok->line_number;
        error = err_regnum3_expected;
        return NULL;
    }
    /* Create instruction */
    encode_op_regs(new_op, op, reg1, reg2, reg3);
    create_instruction(new_op);
    return tok->next;
}

static token_list * two_reg_op( token_list *t, int op ) {
    int reg1, reg2;
    RW_Robo_Op new_op;
    token_list *tok = t;
    /* Get reg1 */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_reg ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_reg1_expected;
        return NULL;
    }
    reg1 = tok->value;
    /* Eat a comma, get reg2 or first immediate */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_comma ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_comma_expected;
        return NULL;
    }
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t == token_reg ) {
        reg2 = tok->value;
    }
    else if( tok->t == token_num ) {
        reg2 = reg_a;
        create_mova(tok->value);
    }
    else {
        error_line = tok->line_number;
        error = err_regnum2_expected;
        return NULL;
    }
    /* Create instruction */
    encode_op_regs(new_op, op_two_reg, reg1, reg2, op);
    create_instruction(new_op);
    return tok->next;
}

static token_list * one_reg_op( token_list *t, int op ) {
    int reg1;
    RW_Robo_Op new_op;
    token_list *tok = t;
    /* Get reg1 */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_reg ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_reg1_expected;
        return NULL;
    }
    reg1 = tok->value;
    /* Create instruction */
    encode_op_regs(new_op, op_one_reg, reg1, 0, op);
    create_instruction(new_op);
    return tok->next;
}

static token_list * zero_reg_op( token_list *t, int op ) {
    RW_Robo_Op new_op;
    /* Create instruction */
    encode_op_regs(new_op, op_zero_reg, 0, 0, op);
    create_instruction(new_op);
    return t->next;
}

static int check_label( token_list *t ) {
    label_loc_map *map;
    op_list *list;
    int loc;
    /* Check the label->location map */
    map = lmap;
    while( map && !ident_compare(map->name, t->ident) ) {
        map = map->prev;
    }
    if( map ) { /* Found a match */
        return map->location;
    }
    else { /* No match, add to waiting list */
        map = (label_loc_map*)malloc(sizeof(label_loc_map));
        map->name = t->ident;
        map->prev = fmap;
        loc = 0;
        list = ops;
        while( list->next ) {
            list = list->next;
            loc += 5000;
        }
        loc += list->length;
        map->location = loc;
        fmap = map;
        return 0;
    }
}

static token_list * branch_op( token_list *t ) {
    int reg, dest;
    RW_Robo_Op new_op;
    token_list *tok = t;
    int type = tok->t;
    /* Check if we need a test instruction */
    if( tok->t != token_call && tok->t != token_jump ) {
        /* Get reg1 */
        tok = tok->next;
        if( !tok ) {
            error = err_unexpected_eof;
            return NULL;
        }
        else if( tok->t != token_reg ) {
            /* Syntax error */
            error_line = tok->line_number;
            error = err_reg1_expected;
            return NULL;
        }
        reg = tok->value;
        /* Create test instruction */
        encode_op_regs(new_op, op_one_reg, reg, 0, op_test);
        create_instruction(new_op);
        /* Eat comma */
        tok = tok->next;
        if( !tok ) {
            error = err_unexpected_eof;
            return NULL;
        }
        else if( tok->t != token_comma ) {
            /* Syntax error */
            error_line = tok->line_number;
            error = err_comma_expected;
            return NULL;
        }
    }
    /* Every branch instruction has at least 1 dest */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_label && tok->t != token_num ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_labelnum_expected;
        return NULL;
    }
    if( tok->t == token_label ) {
        dest = check_label(tok);
    }
    else { /* tok->t == token_num */
        dest = tok->value;
    }
    /* Create first (and possibly last) branch instruction */
    if( type == token_jump || type == token_ifg || type == token_ifeg ) {
        encode_op_imme(new_op, op_jump, dest);
        create_instruction(new_op);
    }
    else {
        encode_op_imme(new_op, op_call, dest);
        create_instruction(new_op);
    }
    /* Do we have a second branch instruction we need to make? */
    if( type == token_ife || type == token_ifeg ) {
        /* Eat comma */
        tok = tok->next;
        if( !tok ) {
            error = err_unexpected_eof;
            return NULL;
        }
        else if( tok->t != token_comma ) {
            /* Syntax error */
            error_line = tok->line_number;
            error = err_comma_expected;
            return NULL;
        }
        tok = tok->next;
        if( !tok ) {
            error = err_unexpected_eof;
            return NULL;
        }
        else if( tok->t != token_label && tok->t != token_num ) {
            /* Syntax error */
            error_line = tok->line_number;
            error = err_labelnum_expected;
            return NULL;
        }
        if( tok->t == token_label ) {
            dest = check_label(tok);
        }
        else { /* tok->t == token_num */
            dest = tok->value;
        }
        /* Create second branch instruction */
        if( type == token_ifeg ) {
            encode_op_imme(new_op, op_jump, dest);
            create_instruction(new_op);
        }
        else {
            encode_op_imme(new_op, op_call, dest);
            create_instruction(new_op);
        }
    }
    return tok->next;
}

static token_list * push_op( token_list *t ) {
    token_list *tok = t;
    int dest, reg;
    RW_Robo_Op new_op;
    /* Push can take a register, immediate, or label.
       This makes things a bit hairy, as we don't have an instruction for both
       immediates and registers. Therefor, we have two different instructions,
       and pick which one depending on what we got. */
    tok = t->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t == token_reg ) {
        reg = tok->value;
        encode_op_regs(new_op, op_one_reg, reg, 0, op_pushr);
    }
    else if( tok->t == token_num ) {
        dest = tok->value;
        encode_op_imme(new_op, op_push, dest);
    }
    else if( tok->t == token_label ) {
        dest = check_label(tok);
        encode_op_imme(new_op, op_push, dest);
    }
    else {
        error_line = tok->line_number;
        error = err_labelnumreg_expected;
        return NULL;
    }
    create_instruction(new_op);
    return tok->next;
}

static token_list * create_label( token_list *t ) {
    int loc;
    token_list *tok = t;
    label_loc_map *new_entry, *map;
    op_list *list = ops;
    /* Check for duplicate label entry */
    map = lmap;
    while( map ) {
        if( ident_compare(map->name, t->ident) ) {
            /* Duplicate entry, error */
            error_line = t->line_number;
            error = err_duplabel;
            return NULL;
        }
        map = map->prev;
    }
    /* Create label entry */
    new_entry = (label_loc_map*)malloc(sizeof(label_loc_map));
    new_entry->name = tok->ident;
    loc = 0;
    while( list->next ) {
        list = list->next;
        loc += 5000;
    }
    new_entry->location = loc + list->length;
    new_entry->prev = lmap;
    lmap = new_entry;
    /* Correct any instructions that are waiting for this label */
    map = fmap;
    while( map ) {
        if( ident_compare(map->name, new_entry->name) ) {
            /* Found a match, update with correct location */
            update_branch_instruction(map, new_entry->location);
        }
        map = map->prev;
    }
    /* Eat a colon */
    tok = tok->next;
    if( !tok ) {
        error = err_unexpected_eof;
        return NULL;
    }
    else if( tok->t != token_colon ) {
        /* Syntax error */
        error_line = tok->line_number;
        error = err_colon_expected;
        return NULL;
    }
    return tok->next;
}

static int parse_token_list() {
    token_list *tok;
    tok = tl;
    ops = new_op_list();
    while( tok != NULL ) {
        switch( tok->t ) {
            /* 3-register instructions */
            case token_add:
                tok = three_reg_op(tok, op_add); break;
            case token_and:
                tok = three_reg_op(tok, op_and); break;
            case token_arccos:
                tok = three_reg_op(tok, op_arccos); break;
            case token_arcsin:
                tok = three_reg_op(tok, op_arcsin); break;
            case token_arctan:
                tok = three_reg_op(tok, op_arctan); break;
            case token_cos:
                tok = three_reg_op(tok, op_cos); break;
            case token_dist:
                tok = three_reg_op(tok, op_dist); break;
            case token_div:
                tok = three_reg_op(tok, op_div); break;
            case token_eq:
                tok = three_reg_op(tok, op_eq); break;
            case token_gt:
                tok = three_reg_op(tok, op_gt); break;
            case token_lt:
                tok = three_reg_op(tok, op_lt); break;
            case token_max:
                tok = three_reg_op(tok, op_max); break;
            case token_min:
                tok = three_reg_op(tok, op_min); break;
            case token_mod:
                tok = three_reg_op(tok, op_mod); break;
            case token_mul:
                tok = three_reg_op(tok, op_mul); break;
            case token_ne:
                tok = three_reg_op(tok, op_ne); break;
            case token_or:
                tok = three_reg_op(tok, op_or); break;
            case token_sin:
                tok = three_reg_op(tok, op_sin); break;
            case token_sub:
                tok = three_reg_op(tok, op_sub); break;
            case token_tan:
                tok = three_reg_op(tok, op_tan); break;
            case token_xor:
                tok = three_reg_op(tok, op_xor); break;
            /* 2-register instructions */
            case token_abs:
                tok = two_reg_op(tok, op_abs); break;
            case token_chs:
                tok = two_reg_op(tok, op_chs); break;
            case token_mov:
                tok = two_reg_op(tok, op_mov); break;
            case token_not:
                tok = two_reg_op(tok, op_not); break;
            case token_setparam:
                tok = two_reg_op(tok, op_setparam); break;
            case token_sqrt:
                tok = two_reg_op(tok, op_sqrt); break;
            case token_vrecall:
                tok = two_reg_op(tok, op_vrecall); break;
            case token_vstore:
                tok = two_reg_op(tok, op_vstore); break;
            /* 1-register instructions */
            case token_icon:
                tok = one_reg_op(tok, op_icon); break;
            case token_peek:
                tok = one_reg_op(tok, op_peek); break;
            case token_pop:
                tok = one_reg_op(tok, op_pop); break;
            case token_print:
                tok = one_reg_op(tok, op_print); break;
            case token_random:
                tok = one_reg_op(tok, op_random); break;
            case token_roll:
                tok = one_reg_op(tok, op_roll); break;
            case token_sound:
                tok = one_reg_op(tok, op_sound); break;
            case token_test:
                tok = one_reg_op(tok, op_test); break;
            case token_debug:
                tok = one_reg_op(tok, op_debug); break;
            /* 0-register instructions */
            case token_beep:
                tok = zero_reg_op(tok, op_beep); break;
            case token_drop:
                tok = zero_reg_op(tok, op_drop); break;
            case token_dropall:
                tok = zero_reg_op(tok, op_dropall); break;
            case token_dup:
                tok = zero_reg_op(tok, op_dup); break;
            case token_end:
                tok = zero_reg_op(tok, op_end); break;
            case token_recall:
                tok = zero_reg_op(tok, op_recall); break;
            case token_return:
                tok = zero_reg_op(tok, op_return); break;
            case token_store:
                tok = zero_reg_op(tok, op_store); break;
            case token_swap:
                tok = zero_reg_op(tok, op_swap); break;
            case token_sync:
                tok = zero_reg_op(tok, op_sync); break;
            case token_nop:
                tok = zero_reg_op(tok, op_nop); break;
            /* Branching instructions */
            case token_if:
            case token_ife:
            case token_ifg:
            case token_ifeg:
            case token_jump:
            case token_call:
                tok = branch_op(tok); break;
            /* Push instruction */
            case token_push:
                tok = push_op(tok); break;
            /* Labels */
            case token_label:
                tok = create_label(tok); break;
            /* Default: Syntax error */
            default:
                /* TODO: error and die */
                error_line = tok->line_number;
                error = err_unknown_token;
                return error;
        }
    }
    return error;
}

/* Need a separate function to recursively walk the tree */
static void free_trie( token_trie *t ) {
    if( !t ) {
        return;
    }
    else {
        free_trie(t->next);
        free_trie(t->child);
        free(t);
    }
}

static void compiler_cleanup() {
    token_list *tokens, *t;
    label_loc_map *map, *m;
    op_list *ol, *o;
    /* Eat token list */
    tokens = tl;
    while( tokens ) {
        t = tokens;
        tokens = tokens->next;
        if( t->ident ) {
            free(t->ident);
        }
        free(t);
    }
    tl_end = NULL;
    free_trie(parser_trie);
    /* Note: The label/loc maps use shallow copies of the ident fields from the
       token list for the name fields. These strings are freed when the token
       list is freed, so we don't have to deal with them here. */
    /* Eat label map */
    map = lmap;
    while( map ) {
        m = map;
        map = map->prev;
        free(m);
    }
    /* Eat branch map */
    map = fmap;
    while( map ) {
        m = map;
        map = map->prev;
        free(m);
    }
    /* Eat tentative instruction list */
    ol = ops;
    while( ol ) {
        o = ol;
        ol = ol->next;
        free(o);
    }
}

const char * RW_Get_Compiler_Error( int *line_number ) {
    *line_number = error_line;
    switch( error ) {
        case err_no_err:
            return NULL;
        case err_reg1_expected:
            return "Register expected";
        case err_comma_expected:
            return "Comma expected";
        case err_unexpected_eof:
            *line_number = -1; /* No line number for unexpected EOF */
            return "Unexpected end of file";
        case err_regnum2_expected:
            return "Register or number expected";
        case err_regnum3_expected:
            return "Register or number expected";
        case err_labelnum_expected:
            return "Label or number expected";
        case err_duplabel:
            return "Duplicate label";
        case err_colon_expected:
            return "Colon expected";
        case err_labelnumreg_expected:
            return "Label, number, or register expected";
        case err_unknown_token:
            return "Unknown token";
        case err_nonexistant_label:
            return "Non-existant label";
        default:
            return "Unknown error";
    }
}

RW_Robo_Op * RW_Compile_Robot_f( FILE *fp, size_t *length ) {
    int l, i;
    op_list *ol;
    RW_Robo_Op *code = NULL;
    if( build_token_list_f(fp) ) {
        /* Error */
        goto cleanup;
    }
    convert_ident_tokens(); /* This phase can't fail, so no error checking */
    if( parse_token_list() ) {
        /* Error */
        goto cleanup;
    }
    if( fmap ) {
        fprintf(stderr, "%s\n", fmap->name);
        error = err_nonexistant_label;
        goto cleanup;
    }
    /* Convert tentative instruction list into simple array */
    /* Step 1: Find the total length and allocate memory */
    l = 0;
    ol = ops;
    while( ol ) {
        if( ol->next ) {
            l += 5000;
        }
        else {
            l += ol->length;
        }
        ol = ol->next;
    }
    *length = l;
    code = (RW_Robo_Op*)malloc(sizeof(RW_Robo_Op) * l);
    /* Step 2: Copy over the ops */
    l = 0;
    ol = ops;
    while( ol ) {
        for( i = 0; i < ol->length; i++ ) {
            code[l] = ol->ops[i];
            l++;
        }
        ol = ol->next;
    }
    /* Step 3: Cleanup */
    cleanup:
    compiler_cleanup();
    return code;
}
